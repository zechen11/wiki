                         =Predictable Network Interface Names=

==可预见的网卡名==

用v197版本的systemd/udev启动系统，所有本地以太网卡、WLAN和WWAN的接口会被分配到稳定的网卡名,该网卡名是可预见的。这和旧的网卡名方案（"eht0","eth1","wlan0",...）相违背，但可以解决实际问题。

==为啥==

传统的网卡命名方案由内核执行,简单的将驱动检测到的所有网卡按照"eht0"、"eth1"、...的方式命名。现代技术中，驱动检测通常是不可预见的，这意味着只要存在多块网卡，网卡名"eth0","eth1"等的分配通常不再是固定的，可能发生这样的情况：某次启动网卡名为"eth0”的网卡，下次启动它的命名变成了"eth1"。这可能存在严重的安全隐患，例如按照某一命名方案编码的防火墙规则会对不可预见的命名改变非常敏感。

为了修复这个问题，多种解决方案被提出且实现。udev花了很长一段时间来转换到对新的命名方案的支持，该命名方案基于网卡的MAC地址给它们分配永久的命名"ethX"。这种方案存在很多问题，其中包括：需要可写的根目录，而这通常是不可行的；系统的xx会丢失，因为在某个系统上启动OS镜像会导致镜像的配置被改变；实际上在很多系统上MAC地址并不固定，例如在许多嵌入式硬件上，尤其是在各种虚拟化场景中。然而最大的问题是：如果用户空间组件尝试分配网卡名，则可能会和内核抢夺"ehtX"命名空间中的相同网卡名。该竞争条件会导致各种奇怪的影响，其中包括有时网卡名分配失败。结果，不久该支持就被从systemd/udev中移除。

另一个被实现的解决方案是：“biosdevname”（BIOS设备名），试图在某些固件接口中找到槽的固定的拓扑信息，并用它们来给网卡分配固定的命名，该命名包含了网卡在主板上的物理位置。在某种程度上，该命名方案和udev已原生实现的通过/dev/*/by-path/链接访问多个设备节点的方案类似。在很多情况下，BIOS设备名方案放弃使用低级别的内核设备检测方案，udev通常对这些链接使用，转而发明其自身的枚举方案。

最后，作为网络脚本的一部分，许多发行版仍然支持将网卡重命名为用户选择的名字（考虑：“internet0”，“dmz0”，...），这些名字键入了对应的MAC地址或物理位置。这是一个非常好的选择，但是会产生问题：用户是否愿意且有能力自己选择和分配网卡名？

我们相信推广“biosdevnam”首创的方案是个好的默认选择。基于固件/拓扑/位置信息分配固定网卡名有个巨大的优点：命名是自动的，完全可预见的,即使增加或移除硬件，命名也是固定的(例如，不会产生重新枚举),且损坏的硬件可以被无缝的更换。当然，据说有时候新网卡名比以前的“eth0”或“wlan0”要难读,例如：“enp5s0”。

==v197版本中到底改变了啥？==

随着systemd 197版本，我们已经向systemd/udevd适当地添加了对一系列不同命名策略的支持,并且实现了一个类似于"biosdevname"的方案（但是通常更强大，更接近内核内部设备检测方案）。udev现在原生支持下列不同的网卡命名方案：

1. 结合固件/BIOS提供的板载设备索引号命名（例如：enol）

2. 结合固件/BIOS提供的PCI扩展热插拔槽索引号命名（例如：ensl）

3. 结合硬件连接器的物理/地理位置命名（例如：enp2s0）

4. 结合网卡的MAC地址命名（例如：enx78e7dlea46da）

5. 经典（传统）的，不可预期的内核原生ethX命名方案（例如：eth0）

默认情况下，如果固件能返回板载设备索引号且其可用，197版本的systemd现在将遵循方案1来命名网卡;否则，如果固件能返回PCI扩展热插拔槽索引号且其可用,则回落到方案2;再否则，若硬件连接器的物理/地理位置可用，回落到方案3；所有其他情况都采用方案5。方案4默认不使用，但用户可以选择使用它。

该复合方案仅作为最后手段。那意味着，如果系统安装了biosdevname，将优先考虑它。如果用户添加了udev规则，改变内核设备名，这些也都将被优先考虑。任何发行版也通常会优先考虑。


==又来了，这么做有啥好处？==

通过这些新方案，你现在得到如下特性：

* 重启后网卡名不变
* 即使添加或移除硬件，网卡也保持名不变，例如无需重新枚举
* 升级/更换内核或驱动，网卡名保持不变
* 即使不得不用新网卡换掉坏掉的网卡,网卡名不变
* 无需用户配置，网卡名是自动检测的
* 网卡名可以完全预见，例如，只需要通过lspci查看下，你就能推算出某块网卡将被如何命名
* 完全无状态操作（），改变硬件配置不会改变/etc中的内容
* 兼容只读根目录
* 网卡命名更加遵守通过链接给/dev中块设备节点和其他设备节点取别名的策略
* 同时适用于x86和非x86机器
* 所有采用systemd/udev的发行版的网卡命名方式相同
* 易于选择这些方案之外的方案（见下）

难道这些方案就没有缺点吗？不，有缺点。以前的方案事实上保证了配备单张网卡的主机只可能有一个“eth0”的网卡名。新方案被采用后，管理员在调用网卡命令前，不得不先检查其命名,而以前,他有个好的选择：“eth0”是正确的网卡名。

==我不喜欢这么做，如何禁止？==

基本上，你有如下三个选择：

* 禁止分配固定的网卡名，以便不可预见的内核网卡名得以使用。要达成此目的，只需屏蔽默认方案的udev规则:`ln -s /dev/null /etc/udev/rules.d/80-net-name-slot.rules`
* 创建自己的人工命名方案，例如将你的网卡命名为“internet0”，“dmz0”或“lan0”。为此，创建你自己的udev规则文件并为对应网卡设置NAME属性。确保该规则文件排在默认的规则文件之前，例如通过将其命名为/etc/udev/rules.d/70-my-net-names.rules。
* 更改默认规则文件，以采用一个不同的命名方案，例如为将所有网卡命名为默认带MAC地址前缀：`cp /usr/lib/udev/rules.d/80-net-name-slot.rules /etc/udev/rules.d/80-net-name-slot.rules`，然后编辑该文件，改变所需的行。

==新的命名体系到底什么样？==

这详细记录在[[http://cgit.freedesktop.org/systemd/systemd/tree/src/udev/udev-builtin-net_id.c#n20|net_id built_in的源码]]的注释块中。请参考之，如果你对如何解码新网卡名感兴趣。

Stateless operation is a configuration that does not maintain system information between boots. If all disk volumes in a computer are configured to use a RAM overlay, all overlay information is lost when the system is shut down or rebooted. This is called stateless operation because the state of the device is exactly the same each time it is rebooted.

无状态操作是指一种重启后不保存系统信息的配置。如果某台电脑中所有的磁盘卷被配置成使用RAM覆盖，当系统关机或重启时所有的覆盖信息将丢失。这就叫无状态操作，因为每次重启后设备状态完全一致。
